// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Random = require("bs-platform/lib/js/random.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

var Imports = /* module */[];

function Impl(T) {
  var $less$less$less = function (f, g, x) {
    return Curry._1(f, Curry._1(g, x));
  };
  var handleError = function (effect) {
    var errorRecord_000 = /* dateTime */new Date();
    var errorRecord = /* record */[
      errorRecord_000,
      /* data */effect
    ];
    console.log(errorRecord);
    return errorRecord;
  };
  Random.self_init(/* () */0);
  var logEffect = function (effect) {
    console.log(effect);
    var match = Random.bool(/* () */0);
    if (match) {
      return /* Ok */Block.__(0, [effect]);
    } else {
      return /* Error */Block.__(1, [effect]);
    }
  };
  var apply2 = function (a, b, f) {
    return Curry._2(f, a, b);
  };
  var runEffects = function (callback, onError, param, effectArr) {
    var run__effects = function (length, i, param, effects) {
      var badArray = param[1];
      var goodArray = param[0];
      console.log(effects.length, i, length);
      var match = i < length;
      if (match) {
        console.log(i);
        var partial_arg = i + 1 | 0;
        var run = function (param, param$1) {
          return run__effects(length, partial_arg, param, param$1);
        };
        var res = Curry._1(callback, Caml_array.caml_array_get(effects, i));
        if (res.tag) {
          var errorRecord = Curry._1(onError, res[0]);
          var b = Belt_Option.getWithDefault(badArray, (function (param) {
                  return Caml_array.caml_make_vect(1, errorRecord);
                }));
          return Curry._2(run, /* tuple */[
                      goodArray,
                      b
                    ], effects);
        } else {
          var eff = res[0];
          var g = Belt_Option.getWithDefault(goodArray, (function (param) {
                  return Caml_array.caml_make_vect(1, eff);
                }));
          return Curry._2(run, /* tuple */[
                      g,
                      badArray
                    ], effects);
        }
      } else {
        return /* tuple */[
                goodArray,
                badArray
              ];
      }
    };
    return run__effects(effectArr.length, 0, /* tuple */[
                param[0],
                param[1]
              ], effectArr);
  };
  var makeTestEffect = function (n) {
    return /* TestEffect */Block.__(0, [n]);
  };
  var myArray = $$Array.init(20, makeTestEffect);
  var test = runEffects(logEffect, handleError, /* tuple */[
        undefined,
        undefined
      ], myArray);
  return /* module */[
          /* <<< */$less$less$less,
          /* handleError */handleError,
          /* logEffect */logEffect,
          /* apply2 */apply2,
          /* runEffects */runEffects,
          /* makeTestEffect */makeTestEffect,
          /* myArray */myArray,
          /* test */test
        ];
}

function $less$less$less(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function handleError(effect) {
  var errorRecord_000 = /* dateTime */new Date();
  var errorRecord = /* record */[
    errorRecord_000,
    /* data */effect
  ];
  console.log(errorRecord);
  return errorRecord;
}

Random.self_init(/* () */0);

function logEffect(effect) {
  console.log(effect);
  var match = Random.bool(/* () */0);
  if (match) {
    return /* Ok */Block.__(0, [effect]);
  } else {
    return /* Error */Block.__(1, [effect]);
  }
}

function apply2(a, b, f) {
  return Curry._2(f, a, b);
}

function runEffects(callback, onError, param, effectArr) {
  var run__effects = function (length, i, param, effects) {
    var badArray = param[1];
    var goodArray = param[0];
    console.log(effects.length, i, length);
    var match = i < length;
    if (match) {
      console.log(i);
      var partial_arg = i + 1 | 0;
      var run = function (param, param$1) {
        return run__effects(length, partial_arg, param, param$1);
      };
      var res = Curry._1(callback, Caml_array.caml_array_get(effects, i));
      if (res.tag) {
        var errorRecord = Curry._1(onError, res[0]);
        var b = Belt_Option.getWithDefault(badArray, (function (param) {
                return Caml_array.caml_make_vect(1, errorRecord);
              }));
        return Curry._2(run, /* tuple */[
                    goodArray,
                    b
                  ], effects);
      } else {
        var eff = res[0];
        var g = Belt_Option.getWithDefault(goodArray, (function (param) {
                return Caml_array.caml_make_vect(1, eff);
              }));
        return Curry._2(run, /* tuple */[
                    g,
                    badArray
                  ], effects);
      }
    } else {
      return /* tuple */[
              goodArray,
              badArray
            ];
    }
  };
  return run__effects(effectArr.length, 0, /* tuple */[
              param[0],
              param[1]
            ], effectArr);
}

function makeTestEffect(n) {
  return /* TestEffect */Block.__(0, [n]);
}

var myArray = $$Array.init(20, makeTestEffect);

var test = runEffects(logEffect, handleError, /* tuple */[
      undefined,
      undefined
    ], myArray);

exports.Imports = Imports;
exports.Impl = Impl;
exports.$less$less$less = $less$less$less;
exports.handleError = handleError;
exports.logEffect = logEffect;
exports.apply2 = apply2;
exports.runEffects = runEffects;
exports.makeTestEffect = makeTestEffect;
exports.myArray = myArray;
exports.test = test;
/*  Not a pure module */
